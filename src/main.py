import os
import re
import subprocess
import generate_server_info
import fetch_cve_data
import llm
import psycopg2
from psycopg2 import sql
from dotenv import load_dotenv
import json




# Function to extract SQL queries from the LLM response
def extract_sql_queries(response):
    """Extract SQL queries from the LLM response."""
    queries = []
    # Using regex to extract SQL queries between ```sql``` blocks
    sql_blocks = re.findall(r'```sql(.*?)```', response, re.DOTALL)
    for block in sql_blocks:
        queries.append(block.strip())
    return queries

# Function to execute SQL queries
def execute_queries(queries, connection):
    """Execute SQL queries on the PostgreSQL database."""
    with connection.cursor() as cur:
        for query in queries:
            try:
                modified_query = modify_table_name(query, 'node_cve_report')
                print(f"Executing query: {modified_query}")
                cur.execute(modified_query)
                connection.commit()
                print(f"Executed query: {query}")
            except psycopg2.Error as e:
                print(f"Error executing query: {e}")
                connection.rollback()

def modify_table_name(query, new_table_name):
    # Use regex to find and replace the table name in the query
    modified_query = re.sub(r'INSERT INTO \w+', f'INSERT INTO {new_table_name}', query)
    return modified_query

def main():
    server_info_path = "data/server_info.json"
    cve_data_path = "data/cve_data.json"

    # Generate server information
    installed_software = generate_server_info.collect()

    try:
        # Establish database connection
        with psycopg2.connect(**conn_params) as connection:
            # Create table if not exists
            create_query = """
            CREATE TABLE IF NOT EXISTS node_cve_report (
                id INT PRIMARY KEY,
                cve_id VARCHAR(20) NOT NULL,
                vendor VARCHAR(50) NOT NULL,
                product VARCHAR(100) NOT NULL,
                version VARCHAR(100),
                impact_score VARCHAR(10),
                criticality CHAR(1),
                cvss_score DECIMAL(3, 1)
            );
            """
            execute_queries([create_query], connection)

            cve_data = fetch_cve_data.fetch()

            with open(cve_data_path, 'r') as f:
                cve_data = json.load(f)

            relevant_cves = [
                cve for cve in cve_data
                if any(
                    cve["cveMetadata"].get("assignerShortName") in software["name"]
                    for software in installed_software["installed_software"]
                )
            ]
          
            prompt_response = llm.analyze_cve_data(relevant_cves)
            response_file = "data/prompt_response.txt"

            # Write prompt response to file
            with open(response_file, 'w') as file:
                file.write(prompt_response)

            # Execute SQL queries from prompt response
            if prompt_response:
                queries = extract_sql_queries(prompt_response)
                print(queries)
                if queries:
                    execute_queries(queries, connection)

            # connection.close()
            # offset = 0
            # limit = 1
            # more_records = True

            # while more_records:
            #     # Fetch CVE data
            #     more_records = fetch_cve_data.fetch(offset, limit)
            #     offset += limit

            #     # Get prompt response
            #     prompt_response = llm.analyze_cve_data(server_info_path, cve_data_path)
                
            #     response_file = f"data/prompt_response{offset}.txt"
            #     # Write prompt response to file
            #     with open(response_file, 'w') as file:
            #         file.write(prompt_response)

            #     # Execute SQL queries from prompt response
            #     if prompt_response:
            #         queries = extract_sql_queries(prompt_response)
            #         print(queries)
            #         if queries:
            #             execute_queries(queries, connection)

            # connection.close()
            # print("All records processed.")
            
    except psycopg2.Error as e:
        print(f"Database connection error: {e}")

    print("Fin.")

if __name__ == "__main__":
    
    # Load environment variables
    load_dotenv()

    conn_params = {
        "dbname": os.getenv("DATABASE_NAME"),
        "user": os.getenv("DATABASE_USER"),
        "password": os.getenv("DATABASE_PASSWORD"),
        "host": os.getenv("DATABASE_HOST"),
        "port": os.getenv("DATABASE_PORT")
    }
    
    main()






# import os
# import re
# import subprocess
# import generate_server_info
# import fetch_cve_data
# import llm
# import psycopg2
# from dotenv import load_dotenv


# # Function to extract SQL queries from the LLM response
# def extract_sql_queries(response):
#     """Extract SQL queries from the LLM response."""
#     queries = []
#     # Using regex to extract SQL queries between ```sql``` blocks
#     sql_blocks = re.findall(r'```sql(.*?)```', response, re.DOTALL)
#     for block in sql_blocks:
#         queries.append(block.strip())
#     return queries

# # Function to execute SQL queries
# def execute_queries(queries, connection):
#     """Execute SQL queries on the PostgreSQL database."""
#     cur = connection.cursor()
#     for query in queries:
#         try:
#             cur.execute(query)
#             connection.commit()
#             print(f"Executed query: {query}")
#         except psycopg2.Error as e:
#             print(f"Error executing query: {e}")
#             connection.rollback()
#     cur.close()

# def main():
#     server_info_path = "data/server_info.json"
#     cve_data_path = "data/cve_data.json"
#     response_file = "data/prompt_response.txt"

#     # Generate server information
#     generate_server_info.collect()

#     # # Fetch CVE data
#     fetch_cve_data.fetch()

#     conn_params = {
#         "dbname": os.getenv("DATABASE_NAME"),
#         "user": os.getenv("DATABASE_USER"),
#         "password": os.getenv("DATABASE_PASSWORD"),
#         "host": os.getenv("DATABASE_HOST"),
#         "port": os.getenv("DATABASE_PORT")
#     }

#     # print(os.getenv("DATABASE_NAME"))
#     # print(os.getenv("DATABASE_USER"))
#     # print(os.getenv("DATABASE_PASSWORD"))
#     # print(os.getenv("DATABASE_HOST"))
#     # print(os.getenv("DATABASE_PORT"))

#     connection = psycopg2.connect(**conn_params)
#     # Create table first
#     create_query = "CREATE TABLE IF NOT EXISTS node_cve_report ( id SERIAL PRIMARY KEY, cve_id VARCHAR(255) NOT NULL, application VARCHAR(255) NOT NULL, \
#             version VARCHAR(255), published_date TIMESTAMP, description TEXT, assigner_org_id UUID, state VARCHAR(50), updated_date TIMESTAMP );"
#     execute_queries([create_query], connection)


#     prompt_response = llm.analyze_cve_data(server_info_path, cve_data_path)

#     with open(response_file, 'w') as file:
#         file.write(prompt_response)



#     if prompt_response:
#         queries = extract_sql_queries(prompt_response)
#         if queries:
#             execute_queries(queries, connection)

#     connection.close()

#     print("fin.")


# if __name__ == "__main__":

#     main()
